"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGlobsFromGit = exports.glob = void 0;
var tslib_1 = require("tslib");
var fs_1 = require("fs");
var globrex_1 = tslib_1.__importDefault(require("globrex"));
var globalyzer_1 = tslib_1.__importDefault(require("globalyzer"));
var path_1 = require("path");
var lodash_uniq_1 = tslib_1.__importDefault(require("lodash.uniq"));
var isHidden = /(^|[\\\/])\.[^\\\/\.]/g;
var CACHE = {};
function walk(output, prefix, lexer, opts, dirname, level, ignore) {
    if (dirname === void 0) { dirname = ''; }
    if (level === void 0) { level = 0; }
    if (ignore === void 0) { ignore = []; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var rgx, dir, files, dot, filesOnly, i, len, file, fullpath, relpath, stats, isMatch;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    rgx = lexer.segments[level];
                    dir = path_1.resolve(opts.cwd, prefix, dirname);
                    return [4 /*yield*/, fs_1.promises.readdir(dir)];
                case 1:
                    files = _b.sent();
                    dot = opts.dot, filesOnly = opts.filesOnly;
                    i = 0, len = files.length;
                    _b.label = 2;
                case 2:
                    if (!(i < len)) return [3 /*break*/, 5];
                    fullpath = path_1.join(dir, (file = files[i]));
                    relpath = dirname ? path_1.join(dirname, file) : file;
                    if (!dot && isHidden.test(relpath))
                        return [3 /*break*/, 4];
                    isMatch = lexer.regex.test(relpath);
                    if ((stats = CACHE[relpath]) === void 0) {
                        CACHE[relpath] = stats = fs_1.lstatSync(fullpath);
                    }
                    if (!stats.isDirectory()) {
                        isMatch && output.push(path_1.relative(opts.cwd, fullpath));
                        return [3 /*break*/, 4];
                    }
                    // console.log(basename(relpath))
                    if (ignore && ignore.includes(path_1.basename(relpath))) {
                        return [3 /*break*/, 4];
                    }
                    if (rgx && !rgx.test(file))
                        return [3 /*break*/, 4];
                    !filesOnly && isMatch && output.push(path_1.join(prefix, relpath));
                    return [4 /*yield*/, walk(output, prefix, lexer, opts, relpath, rgx && rgx.toString() !== lexer.globstar && level + 1, ignore)];
                case 3:
                    _b.sent();
                    _b.label = 4;
                case 4:
                    i++;
                    return [3 /*break*/, 2];
                case 5: return [2 /*return*/];
            }
        });
    });
}
/**
 * Find files using bash-like globbing.
 * All paths are normalized compared to node-glob.
 * @param {String} str Glob string
 * @param {String} [options.cwd='.'] Current working directory
 * @param {Boolean} [options.dot=false] Include dotfile matches
 * @param {Boolean} [options.absolute=false] Return absolute paths
 * @param {Boolean} [options.filesOnly=false] Do not include folders if true
 * @param {Boolean} [options.flush=false] Reset cache object
 * @returns {Array} array containing matching files
 */
function glob(str, opts) {
    if (opts === void 0) { opts = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var glob, _b, ignore, gitignore, _c, resolved, dirent, err_1, matches, path;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    if (!str)
                        return [2 /*return*/, []];
                    glob = globalyzer_1.default(str);
                    _b = opts.ignore, ignore = _b === void 0 ? [] : _b, gitignore = opts.gitignore;
                    if (!gitignore) return [3 /*break*/, 2];
                    _c = [ignore];
                    return [4 /*yield*/, exports.getGlobsFromGit()];
                case 1:
                    ignore = tslib_1.__spreadArrays.apply(void 0, _c.concat([(_d.sent())]));
                    _d.label = 2;
                case 2:
                    ignore = lodash_uniq_1.default(ignore);
                    opts.cwd = opts.cwd || '.';
                    if (!!glob.isGlob) return [3 /*break*/, 6];
                    _d.label = 3;
                case 3:
                    _d.trys.push([3, 5, , 6]);
                    resolved = path_1.resolve(opts.cwd, str);
                    return [4 /*yield*/, fs_1.promises.stat(resolved)];
                case 4:
                    dirent = _d.sent();
                    if (opts.filesOnly && !dirent.isFile())
                        return [2 /*return*/, []];
                    return [2 /*return*/, opts.absolute ? [resolved] : [str]];
                case 5:
                    err_1 = _d.sent();
                    if (err_1.code != 'ENOENT')
                        throw err_1;
                    return [2 /*return*/, []];
                case 6:
                    if (opts.flush)
                        CACHE = {};
                    matches = [];
                    path = globrex_1.default(glob.glob, {
                        filepath: true,
                        globstar: true,
                        extended: true,
                    }).path;
                    path.globstar = path.globstar.toString();
                    return [4 /*yield*/, walk(matches, glob.base, path, opts, '.', 0, ignore)];
                case 7:
                    _d.sent();
                    return [2 /*return*/, opts.absolute ? matches.map(function (x) { return path_1.resolve(opts.cwd, x); }) : matches];
            }
        });
    });
}
exports.glob = glob;
exports.getGlobsFromGit = function (data) {
    if (data === void 0) { data = ''; }
    return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var _b, _a_1;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _c.trys.push([0, 3, , 4]);
                    _b = data;
                    if (_b) return [3 /*break*/, 2];
                    return [4 /*yield*/, fs_1.promises.readFile('.gitignore', { encoding: 'utf8' })];
                case 1:
                    _b = (_c.sent());
                    _c.label = 2;
                case 2:
                    data = _b;
                    return [2 /*return*/, data
                            .split('\n')
                            .filter(function (line) { return !/^\s*$/.test(line) && !/^\s*#/.test(line); })
                            .map(function (line) { return line.trim().replace(/^\/+|\/+$/g, ''); })];
                case 3:
                    _a_1 = _c.sent();
                    return [2 /*return*/, []];
                case 4: return [2 /*return*/];
            }
        });
    });
};
//# sourceMappingURL=glob.js.map